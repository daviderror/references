# regex

+ [definition](#definition)
+ [quantifiers](#quantifiers)
+ [special_characters](#special_characters)
+ [backslash_expressions](#backslash_expressions)
+ [lookahead_lookbehind](#lookahead_lookbehind)
+ [flags](#flags)

## definition

regex (регулярные выражения, регулярка, regular expressions) - некий шаблон по которому фильтруется текст.

Написаыв подобный шаблон (регулярку) можно искать в тексте определенные слова, выражения, предложения и тд. Также их используют для автозаполнения (?). Пишутся на разных языках и разынх средах, но при этом не привязанны к их синтаксисам, те не привяхзанны к синтаксически к определенному языку. Пробелы тоже считаюся как символы.

### Метасимволы 
Cтроительные блоки regexp, включают в себя quantifiers, special characters и backslash expressions.

Сайт для тренировки и отладки регулярок: https://www.regextester.com/

## quantifiers

quantifiers (квантификатор) - определяет колличество повторения символа, сочетание символов и тд в тексте.

```
{n}   - символ повторяется ровно n раз;
{n,m} - символ повторяется в диапазоне от n до m раз;
{,m}  - символ повторяется максимум m раз (от 0 до m);
{m,}  - символ повторяется минимум m раз (от m и более);
```
```
Пример (bash, grep):

Найти сочитание символов "aaa".
Регулярка: a{3}
bash: grep -E 'a{3}' file_name
Результат для "a aaa aa aaaa": 2 фрагмента текста

Найти "aa" и "aaa".
Регулярка: a{2,3}
bash: grep -E 'a{2,3}' file_name
Результат для "a aaa aa aaaa": 3 фрагмента текста

Найти "a", "aa" и "aaa".
Регулярка: a{1,3}
bash: grep -E 'a{1,3}' file_name
Результат для "a aaa aa aaaa": 5 фрагмента текстов, те a aaa aa aaa|a так как регулярка уже взяла три из четырёх символа и потом взяла еще одну червёртую как оставшуюсю.
```
```
? - символ повторяется 0 или 1 раз (аналог {0,1});
* - символ повторяется от 0 раз и более (аналог {0,});
+ - символ повторяется от 1 и более раз (аналог {1,});
```
```
Пример (bash, grep):

Найти либо "colour", либо "color".
Регулярка: colou?r, что соответвует colou{0,1}r
bash: grep -E 'colou?r' file_name
Результат для "colour color": 2 фрагмента текста

* и + по аналогии. 
```

### greedy and lazy

todo

## special_characters

```
.   - одиночный символ (кроме новой строки);
[]  - интервал или набор символов;
^   - начало строки, для привязки к первому символ строки;
[^] - отрицание символа, соответсвие всем символам, кроме выбранного;
$   - конец строки, для привязки к пследнему символ строки;
()  - символьная группа;
\   - экранирование, для использования спец символа, как обычного;
```
```
Пример (bash, grep):

Найти любой символ (кроме новой строки), за которым следует буква 'a'.
Регулярка: .a
bash: grep -E '.a' file_name
Результат для "The car parked in the garage.": 4 фрагмента текста

Найти любой символ, за которым следует буква 'a', за которой следует буква 'r'.
Регулярка: .ar
bash: grep -E '.ar' file_name
Результат для "The car parked in the garage.": 3 фрагмента текста

Найти все символы в интервале 'A'-'Z'.
Регулярка: [A-Z]
bash: grep -E '[A-Z]' file_name
Результат для "A number 123 in the 6th Cook Book.": 3 фрагмента текста

Найти все '.' после "ge".
Регулярка: ge[.]
bash: grep -E 'ge[.]' file_name
Результат для "The car parked in the garage.": 1 фрагмент текста

Найти все символы в интервале 'A'-'Z' и 'a'-'z'.
Регулярка: [A-Z,a-z]
bash: grep -E '[A-Z,a-z]' file_name
Результат для "A number 123 in the 6th Cook Book.": всё кроме пробелов, точки и чисел.

Найти набор символов 6th.
Регулярка: [6th]
bash: grep -E '[6th]' file_name
Результат для "A number 123 in the 6th Cook Book.": 5 фрагментов текста, так как порядок символ не важен и поиск идет не по сочитанию символов в [], а по их наличию в тексте.

Найти символы все 'a' за которыми следует 'r' и не следующие за 'c'.
Регулярка: [^c]ar
bash: grep -E '[^c]ar' file_name
Результат для "The car parked in the garage.": 2 фрагмента текста. Обычно '^' определяет начало строки, но в [] исключает интервал или набор символов из поиска.

Найти все "ar".
Регулярка: (ar)
bash: grep -E '(ar)' file_name
Результат для "The car parked in the garage.": 3 фрагмента текста

Найти все "ar" после 'c'.
Регулярка: c(ar)
bash: grep -E 'c(ar)' file_name
Результат для "The car parked in the garage.": 1 фрагмент текста

Найти все "ar" после 'c' или 'p' или 'g'.
Регулярка: (c|p|g)ar
bash: grep -E '(c|p|g)ar' file_name
Результат для "The car parked in the garage.": 3 фрагмента текста

Найти все '.'.
Регулярка: \.
bash: grep -E '\.' file_name
Результат для "The car parked in the garage.": 1 фрагмент текста
```

## backslash_expressions

Сокращения для некоторых special characters.

```
\d  - любая цифра ([0-9]);
\D  - все, кроме цифр ([^\d]);
\s  - пробелы ([\t\n\f\r\p{Z}]);
\S  - все, кроме пробелов (([^\s]));
\w  - буква ([A-Z, a-z]);
\W  - все, кроме букв ([^\w]);
\<  - начало слова; 
\>  - конец слова; 
\A  - начало ввода;
\Z  - конец ввода;
```

## lookahead_lookbehind

lookahead (опережающая проверка) - позволяет выбрать символ или группу символов, если после него идет какой-либо символ или группа символов.

lookbehind (етроспективная проверка) - позволяет выбрать символ или группу символов, если до них идет какой-то символ или группа символов.

```
X(?=Y) - lookahead - найти Х, при условии, что после него идет Y
Х(?!Y) - negative lookahead - найти Х, при условии, что после него не идет Y
(?<=Y)X - lookbehind - найти Х, при условии, что до него идет Y
(?<!Y)X - negative lookbehind - найти Х, при условии, что до него ен идет Y
```
```
Пример (bash, grep):

Найти 'c', при условии, что после него идет "ar".
Регулярка: c(?=ar)
bash: grep -E 'c(?=ar)' file_name
Результат для "The car parked in the garage.": 1 фрагмент текста

Найти 'r'', при условии, что после него не идет 'a'.
Регулярка: r(?=a)
bash: grep -E 'r(?=a)' file_name
Результат для "The car parked in the garage.": 1 фрагмент текста

Найти "ar", при условии, что до него идет 'c'.
Регулярка: (?<=c)ar
bash: grep -E '(?<=c)ar' file_name
Результат для "The car parked in the garage.": 1 фрагмент текста

Найти 'e', при условии, что до него не идет "Th".
Регулярка: (?<!c)ar
bash: grep -E (?<!Th)e' file_name
Результат для "The car parked in the garage.": 1 фрагмент текста
```

## flags
```
i - нечувствительность к регистру: делает выражение нечувствительным к регистру.
g - глобальный поиск: поиск шаблона во всей строке ввода.
m - многострочность: анкер метасимвола работает в каждой строке.
```
```
Пример (bash, grep):

Найти все "the", "The", "tHe" и тд.
Регулярка: /the/i
bash: grep -E '/the/i' file_name
Результат для "The car parked in the garage.": 2 фрагмента текста

Найти все "the", "The", "tHe" и тд.
Регулярка: /the/g
bash: grep -E '/the/g' file_name
Результат для "The car parked in the garage.": 2 фрагмента текста, но поиск будет продолжен после первого совпадения (?).

Найти все "the", "The", "tHe" и тд.
Регулярка: /the/m
bash: grep -E '/the/m' file_name
Результат для "The car parked in the garage.": 2 фрагмента текста (?).
```

