# types

1.  [integer](#integer)
1.  [floating_points](#floating_points)

## integer

    #include <stdint.h> and <inttypes.h>

    intN_t (N == 8, 16, 32, 64)
    int_leastN_t
    int_fastN_t
    intmax_t
    intptr_t
    uintN_t (uint8_t for byte, not char тк char может быть sign or unsign
    в зависимости от платформы, а байт это unsign)
    uint_leastN_t
    uint_fastN_t
    uintmax_t
    uintptr_t

## floating_points
 
    float (32b  может быть знаковым) 
    знак числа(S=1b) экспонента(E=8b) мантиса(M=23b)
    double (double precision 64b может быть знаковым)
    знак числа(S=1b) экспонента(E=11b) мантиса(M=52b)
    long double (64, 80, 128 (в зависимости от платформы) может быть знаковым)

    Перевод в бинарный вид по формуле: (-1)^S x 1.M x 10^E
    Примеры для float: 
    123.456                       -> 
    1111011.01110101              точка смещается до самой крайней уденицы справа, а само число домнажается, 
                                  на соответвующее колличеству сдвигов, степеней десяти) -> 
    1.11101101110101 x 10^6       самая правая еденица и число 10 отбрасываются -> 
    11101101110101 6              экспонента переводится в бинарный вид -> 
    11101101110101 110            шесть суммируется с 127 для обозначения знака экспоненты тк экспоненты
                                  больше 127 положительные -> 
    11101101110101 10000101       числа заполняю соответвующие поля и дополняются нулями до размерности 
                                  типа данных -> 
    0 10000101 11101101110101000000000

    -123.456                      -> 
    1 10000101 11101101110101000000000

    0.123                         -> 
    0.1111011                     точка смещается до самой крайней уденицы слева, а само число домнажается, 
                                  на соответвующее колличеству сдвигов, степеней десяти со знаком минус) ->
    0111101.1 х 10^(-6)           -> 
    0111101 110                   шесть вычитается из 127 для обозначения знака экспоненты тк экспоненты меньше 
                                  127 это отрицательные ->
    0111101 1111001               ->
    0 1111001 01111010000000000000000

    -0.123                        ->
    1 1111001 01111010000000000000000

    Особый случаи:
    S == 1 и E == 255 и M == 0, то число == -бесконечность
    S == 0 и E == 255 и M == 0, то число == +бесконечность
    S == 0/1 и E == 255 и M != 0, то число == NaN (Not a number)

    Литералы; 0.1 (double), 0.1L (lomg double), 0.1f (float)

    Bad case:
```
#include <stdio.h>

if ((0.1 + 0.2) == 0.3) {
	printf("T");
}
else {
	printf("F");
}
```
    printf log: F
```
printf("%.30lf != %.30lf", 0.1 + 0.2, 0.3);
```
    printf log: 0.3000000000000000444 != 0.2999999999999999888

    Good case:
```
#include <stdio.h>
#include <math.h>
 
double res = 0.1 + 0.2;

const double eps = 1e-8, // эпсилон задающий точность
             comp = 0.3;

if (dabs(res - comp) <= eps) { // fabs для float
	printf("T");
}
else {
	printf("F");
}
```
    printf log: T
    
    Но вообще в stdlib есть платформазависимый DBL_EPSILON дефайн.