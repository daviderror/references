# asm

## cpulator

`https://cpulator.01xz.net/`

## compilation

### Single file
```
as -o <asm_file_name>.o <asm_file_name>.s
ld -o <asm_file_name> <asm_file_name>.o 
./<program_name>
```

### Several files
```
as -o <program_name_0>.o <program_name_0>.s
as -o <program_name_1>.o <program_name_1>.s
as -o <program_name_2>.o <program_name_2>.s
ld -o <program_name> <program_name_0>.o <program_name_1>.o <program_name_2>.o
./<program_name>
```

## comments

`@` - one line comment `/* */` - multiline comment

## preogramm_struct

### start of programm
```
.global _start
_start:
```

###

## registers

| register | description      |
| :---     | :---             |
| r0       |                  |
| r1       |                  |
| r2       |                  |
| r3       |                  |
| r4       |                  |
| r5       |                  |
| r6       |                  |
| r7       | system calls     |
| r8       |                  |
| r9       |                  |
| r10      |                  |
| r11      |                  |
| r12      |                  |
| sp       | stack pointer    |
| lr       |                  |
| pc       | programm counter |
| cpsr     |                  |
| sppsr    |                  |
|          |                  |


## instruction

### nop

`asm("mov r0,r0");`

### mov

Перемещает значения регистров процессора между собой.

Synctax: `mov reg_dest,reg_src`

```
mov r0, #30
mov r1, r0
```

### ldr

Загружает значения из стэка в регистр процессора.

Synctax: `ldr reg_dest,mem_data`

```
ldr r0, =list     // ссылка на list
ldr r1, [r0]      // загрузить в r1 значение из r0
ldr r2, [r0, #4]   // загрузить в r2 значение со смещением 4 байта относительно r0
ldr r3, [r0, #4]!  // предварительное приращение адреса в стэке
ldr r4, [r0], #4   // посфиксное приращение адреса в стэке, те подготовка следующего адреса для следующей инструкции
ldr r5, [r0]

.data
list:
    .word 4,5,-9,1,0,2,-3
```

## inline_asm

```
asm(
"mov r0, r0\n\t"
"mov r0, r0\n\t"
"mov r0, r0\n\t"
"mov r0, r0"
);
```

Каждое утверждение asm разделено двоеточиями максимум на четыре части:
`asm(code : output operand list : input operand list : clobber list);`

Rotating bits example:
```
asm("mov %[result], %[value], ror #1" : [result] "=r" (y) : [value] "r" (x));
```

Части инструкции asm могут быть опущены, если они не используются. Если за неиспользуемой частью следует та, которая используется.
Пример 1:
`asm("msr cpsr,%[ps]" : : [ps]"r"(status));`

Пример 2:
`asm("":::"memory");`

Можно вставлять пробелы, нове строки и коментарии:

+ Инструкции ассемблера, определенные в одном строковом литерале;
+ Затем идет необязательный список выходных операндов, разделенных запятыми. Каждая запись состоит из символьного имени, заключенного в квадратные скобки, за которым следует строка ограничения, за которой следует выражение C, заключенное в круглые скобки;
+ Разделенный запятыми список входных операндов, который использует тот же синтаксис, что и список выходных операндов;
+ Необязательный список заблокированных регистров (clobber);

```
asm("mov    %[result], %[value], ror #1"
    "mov    %[result_2], %[result], ror #1"

           : [result]"=r" (y) /* Rotation result. */
           : [value]"r"   (x) /* Rotated value. */
           : /* No clobbers */
    );
```

Встроенные инструкции asm, содержащие только инструкции ассемблера, также известны как базовая встроенная сборка, в то время как инструкции, содержащие необязательные части, называются расширенной встроенной сборкой.

В разделе кода на операнды ссылается знак процента, за которым следует соответствующее символическое имя, заключенное в квадратные скобки.

На операнды ссылается знак процента, за которым следует одна цифра, где % 0 относится к первому, % 1 - ко второму операнду и так далее. Этот формат по-прежнему поддерживается последними версиями GCC, но довольно подвержен ошибкам и сложен в обслуживании. Представьте, что вы написали большое количество инструкций ассемблера, где операнды должны быть перенумерованы вручную после вставки нового выходного операнда.
