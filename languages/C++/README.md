# C++

+ [](#)

## оптимизация кода

сайтики: https://eax.me/effective-optimization/

Задача найти медленное место и ускорить его. Так по кругу, пока есть возможность находить медленные места (относительно прошлого медленного места) и их оптимизировать. Делается это с помощью профилировщика,сборки метрик, отладочного вывода с временными метками.

Мемоизация — это сохранение значения, возвращаемого функцией для заданных аргументов. 

Кэширование — это сохранение результатов чего угодно.

Стектрейс - последовательность вызовов и состояние окружения в некоторой точке программы

+ старые либы медленнее новых
+ старые инструменты медленнее новых
+ старое железо медленнее нового
+ неправильно настроенный инструмент (в том числе ОС) замедляют работу программы
+ распаралеливание ускаряет работу программы

+ `i = i + 1` медленнее `i++`

+ `for` медленнее `while`

```
for (int i = 0; i < NUM; i = i + 1) {  // медленно, даже при условии  i = i + 1 вместо i++
	// some code 
}

int i = 0;

while (i < NUM) {
	//some code 
	i = i + 1;
}
```

+ `while (true) ...` медленнее `while (!false) ...` тк сравнение с 0 всегда быстрее.
+ `int a = 1, b = 2, c = 3;` медленнее 

```
int a;
int b;
int c;
a = 1;
b = 2;
c = 3;
```
тк перекладывается часть работы на компилятор.

+ Применение спецификатора `register` при объявление переменной ускаряет программу. Очень хорошо это проявляет себя в итераторах циклов.
+ Индексация массива медленней, трудозатратнее и объемнее чем приращение указателя
```
while(1) { // медленней
    a = array[t++];
}
```

```
p = array;
while(1) { // быстрее
    a = *(p++);
}
```
+ функции


### профилирование кода

+ замера времени 

Лучше юзать в дебаге, тк сами функции по работе со временем очень дорогие. Так же могут появиться разные значения времени тк скедулер потоков может перелючиться на другую задачу между замерами.

```
#include <sys/time.h>

/* ... */

struct timeval  tv;
gettimeofday(&tv, NULL);

double time_begin = ((double)tv.tv_sec) * 1000 +
                      ((double)tv.tv_usec) / 1000;

/* ... */

gettimeofday(&tv, NULL);
double time_end = ((double)tv.tv_sec) * 1000 +
                    ((double)tv.tv_usec) / 1000 ;

double total_time_ms = time_end - time_begin;

printf("TOTAL TIME (ms) = %f\n", total_time_ms);
```

+ gdb
+ strace и ltrace
+ gprof и gprof2dot для gcc
+ bcc/eBPF