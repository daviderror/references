//todo: 1. realize all uart features
//      2. infer interrupts
//      3. XUARTPS_CR_OFFSET(0): XUARTPS_CR_STOPBRK, XUARTPS_CR_STARTBRK, XUARTPS_CR_TORST
//      4. add _ all static

#include "xscugic.h"

#include "ps_uart.h"

static uint32_t ii = 0;

//todo: do it not hardcore
char *un_block_array[2];
bool tx_ready[2] = {false, false};
uint32_t num[2];

//---------------------------------------------upper half---------------------------------------------//
static inline int init_driver_(ps_uart_handle *p_handle,
								  bool do_init);

static inline status  check_params_(ps_uart_handle *p_handle);
static inline void read_un_block_mode_data_();
static inline void read_block_mode_data_(ps_uart_regs *p_uart_regs, char *p_data, size_t size);
static inline void write_un_block_mode_data_();
static inline void write_block_mode_data_(ps_uart_regs *p_uart_regs, char *p_data, size_t size);

//---------------------------------------------lower half---------------------------------------------//
static inline void set_stop_bits(ps_uart_regs *p_reg_base, ps_uart_stop_bits stop_bits, bool do_setting);
static inline void set_parity_type(ps_uart_regs *p_reg_base, ps_uart_parity_type parity_type, bool do_setting);
static inline void set_data_bits(ps_uart_regs *p_reg_base, ps_uart_data_bits data_bits, bool do_setting);
static inline void set_channel_mode_(ps_uart_regs *p_reg_base, ps_uart_channel_mode channel_mode, bool do_setting);
static inline void set_baud_rate(ps_uart_regs *p_reg_base, uint32_t baud_rate, bool do_setting);
static inline char get_data_word_(ps_uart_regs *p_reg_base);
static inline void set_data_word_(ps_uart_regs *p_reg_base, char data);
static inline void set_tx_enable_(ps_uart_regs *p_reg_base, bool do_setting);
static inline void set_reset_(ps_uart_regs *p_reg_base, ps_uart_path_reset path_reset, bool *reset_done);
static inline void set_interrupt_(ps_uart_regs *p_uart_regs, uint32_t interrupt_mask); //uint32_t??
static inline void set_rx_fifo_level(ps_uart_regs *p_reg_base, uint8_t rx_fifo_level, bool do_setting);

static void intrrupt_handler(void *callback);

//---------------------------------------------upper half---------------------------------------------//

status ps_uart_init(ps_uart_handle *p_handle)
{
	if (NULL == p_handle) {
			return prm_error;
	}

	return init_driver_(p_handle, true);
}

status ps_uart_release(ps_uart_handle *p_handle)
{
	if (true != p_handle->init) {
         return un_init;
	}

	return init_driver_(p_handle, false);
}

status ps_uart_read(ps_uart_handle *p_handle, char *p_data, size_t size)
{
	if ((NULL == p_handle) || (NULL == p_data) || (0 == size)) {
	    return prm_error;
	}

	if (false != p_handle->init) {
		return un_init;
	}

	p_handle->ready = false;

	if (true == p_handle->do_unblocking_mode) {
		read_un_block_mode_data_((ps_uart_regs *) p_handle->id, p_data, size);
	}
	else {
		read_block_mode_data_((ps_uart_regs *) p_handle->id, p_data, size);
		p_handle->ready = true;
	}

	return ok;
}

status ps_uart_write(ps_uart_handle *p_handle, char *p_data, size_t size)
{
	if ((NULL == p_handle) || (NULL == p_data) || (0 == size)) {
		return prm_error;
	}

	if (false != p_handle->init) {
	    return un_init;
	}

	p_handle->ready = false;

	if (true == p_handle->do_unblocking_mode) {
		write_un_block_mode_data_((ps_uart_regs *) p_handle->id, p_data, size);
	}
	else {
		write_block_mode_data_((ps_uart_regs *) p_handle->id, p_data, size);
		p_handle->ready = true;
	}

	return ok;
}

status ps_uart_reset(ps_uart_handle *p_handle, ps_uart_path_reset path_reset, bool *reset_done)
{
	if ((NULL == p_handle) || (NULL == reset_done)) {
	    return prm_error;
	}

	if ((path_reset < tx) || (path_reset > both)) {
	    return prm_error;
	}

	if (false != p_handle->init) {
	    return un_init;
	}

	set_reset_((ps_uart_regs* ) p_handle->id, path_reset, reset_done);

	return ok;
}

static inline int init_driver_(ps_uart_handle *p_handle, bool do_init)
{
	bool reset_done = false;

	const uint32_t rx_fifo_level = 10;

	p_handle->ready = false;
	p_handle->init  = 0;

	if (none_id == p_handle->id) {
		 return -1;
	}

	if (0 != check_params_(p_handle)) {
		return p_handle->init;
	}

	//todo: reset done??
	set_reset_((ps_uart_regs* )p_handle->id, both, &reset_done);

	set_tx_enable_((ps_uart_regs* )p_handle->id, false);

	set_stop_bits   ((ps_uart_regs* )p_handle->id, init->stop_bits, do_init);
	set_parity_type ((ps_uart_regs* )p_handle->id, init->parity_type, do_init);
	set_data_bits   ((ps_uart_regs* )p_handle->id, init->data_bits, do_init);
	set_channel_mode_((ps_uart_regs* )p_handle->id, init->channel_mode, do_init);
	set_baud_rate   ((ps_uart_regs* )p_handle->id, init->baud_rate, do_init);
	set_rx_fifo_level ((ps_uart_regs* )p_handle->id, rx_fifo_level, do_init);

	if (true == do_init) {
		//set_enable_((ps_uart_regs* )p_handle->id, true);
		p_handle->init = 0;
		p_handle->ready = true;
/*--------------------------------------------------------------------------------------*/
		XScuGic InterruptController;

		XScuGic_Config *GicConfig;

		GicConfig = XScuGic_LookupConfig(XPAR_PS7_UART_1_DEVICE_ID);
		XScuGic_CfgInitialize(&InterruptController, GicConfig,
							GicConfig->CpuBaseAddress);
		Xil_ExceptionInit();
		Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
					(Xil_ExceptionHandler) XScuGic_InterruptHandler,
					&InterruptController);
		Xil_ExceptionEnable();
		XScuGic_Connect(&InterruptController, 82,
					(Xil_ExceptionHandler) intrrupt_handler, (void *)&InterruptController);

		XScuGic_SetPriorityTriggerType(&InterruptController, 82,
								8, 0b11);
		XScuGic_InterruptMaptoCpu(&InterruptController, 0, 82);
		XScuGic_Enable(&InterruptController, 82);
/*--------------------------------------------------------------------------------------*/
	}

	return 0;
}
//id!
static inline int check_params_(ps_uart_handle *p_handle) {
	const uint32_t highest_setup_value = 2,
		           lowest_baud_rate_value = 300;

    if ((0 == baud_rate) || ((highest_setup_value < baud_rate) &&
    	               (lowest_baud_rate_value > baud_rate))) {
    	return -1;
    }

    return 0;
}

static inline void read_un_block_mode_data_() {



}

static inline void read_block_mode_data_(ps_uart_regs *p_uart_regs, char *p_data, size_t size) {
	uint32_t i = 0;

	for (i = 0; i < size; i++) {
		p_data[i] = get_data_word_(p_uart_regs);
	}
}

static inline void write_un_block_mode_data_(ps_uart_regs *p_uart_regs, char *p_data, size_t size) {
    uint32_t i = 0;
    const uint32_t interrupt_mask = 0x1FF;

    //todo:hardcode: 0
    un_block_array[0] = p_data;
    num[0] = size;
    ii = 1;

    set_interrupt_(p_uart_regs, interrupt_mask);

    for(i = 0; i < size; i++) {
    	//while (tx_ready[0]) {
    	   set_data_word_(p_uart_regs , p_data[i]);
    	//}

	}

    //set_tx_enable_(p_uart_regs, true);

   // set_data_word_(p_uart_regs, p_data[i]);
}

static inline void write_block_mode_data_(ps_uart_regs *p_uart_regs, char *p_data, size_t size) {
	uint32_t i = 0;

	//todo: only tx
	set_tx_enable_(p_uart_regs, true);

	for(i = 0; i < size; i++) {
		set_data_word_(p_uart_regs , p_data[i]);
	}
}

//---------------------------------------------lower half---------------------------------------------//

static inline void set_stop_bits(ps_uart_regs *p_reg_base, ps_uart_stop_bits stop_bits, bool do_setting) {

	p_reg_base->mode &= ~((TRUE << PS_UART_STOP_NUM_BIT_0_OFFSET) | (TRUE << PS_UART_STOP_NUM_BIT_1_OFFSET));

	if (true == do_setting) {
		p_reg_base->mode |= (stop_bits << PS_UART_STOP_NUM_BIT_0_OFFSET);
	}
	else {
		p_reg_base->mode |= (PS_UART_MODE_REG_RESET_VALUE & PS_UART_STOP_NUM_BIT_MASK);
	}
}

static inline void set_parity_type(ps_uart_regs *p_reg_base, ps_uart_parity_type parity_type, bool do_setting) {
	p_reg_base->mode &= ~((TRUE << PS_UART_PAR_TYP_BIT_0_OFFSET) | (TRUE << PS_UART_PAR_TYP_BIT_1_OFFSET));

	if (true == do_setting) {
		p_reg_base->mode |= (parity_type << PS_UART_PAR_TYP_BIT_0_OFFSET);
	}
	else {
		p_reg_base->mode |= (PS_UART_MODE_REG_RESET_VALUE & PS_UART_PAR_TYP_BIT_MASK);
	}
}

static inline void set_data_bits(ps_uart_regs *p_reg_base, ps_uart_data_bits data_bits, bool do_setting) {
	p_reg_base->mode &= ~((TRUE << PS_UART_DATA_NUM_BIT_0_OFFSET) | (TRUE << PS_UART_DATA_NUM_BIT_1_OFFSET));

	if (true == do_setting) {
		p_reg_base->mode |= (data_bits << PS_UART_DATA_NUM_BIT_0_OFFSET);
	}
	else {
		p_reg_base->mode |= (PS_UART_MODE_REG_RESET_VALUE & PS_UART_DATA_NUM_BIT_MASK);
	}
}

static inline void set_channel_mode_(ps_uart_regs *p_reg_base, ps_uart_channel_mode channel_mode, bool do_setting) {
	p_reg_base->mode &= ~((TRUE << PS_UART_CHNL_MD_BIT_0_OFFSET) | (TRUE << PS_UART_CHNL_MD_BIT_1_OFFSET));

	if (true == do_setting) {
		p_reg_base->mode |= (channel_mode << PS_UART_CHNL_MD_BIT_0_OFFSET);
	}
	else {
		p_reg_base->mode |= (PS_UART_MODE_REG_RESET_VALUE & PS_UART_CHNL_MD_BIT_MASK);
	}
}

//XPAR_CPU_CORTEXA9_0_CPU_CLK_FREQ_HZ
static void set_baud_rate(ps_uart_regs *p_reg_base, uint32_t baud_rate, bool do_setting) {
	p_reg_base->mode &= ~(TRUE << PS_UART_CLK_SELECT_BIT_0_OFFSET);
	p_reg_base->baud_rate_divider = 0;

	if (true == do_setting) {
		if (PS_UART_BD_GN_REG_DSABLE_VALUE == baud_rate) {
			p_reg_base->baud_rate_generator = PS_UART_BD_GN_REG_DSABLE_VALUE;
			p_reg_base->mode |= (PS_UART_MODE_REG_RESET_VALUE & PS_UART_CLK_SELECT_BIT_MASK);
			p_reg_base->baud_rate_divider = PS_UART_BD_RT_REG_RESET_VALUE;
		}
		else if (PS_UART_CLK_SELECT_DIV8_VALUE == baud_rate){
			p_reg_base->baud_rate_generator = PS_UART_BD_GN_REG_BPASS_VALUE;
			p_reg_base->mode |= (PS_UART_CLK_SELECT_DIV8_VALUE << PS_UART_CLK_SELECT_BIT_0_OFFSET);
			p_reg_base->baud_rate_divider = PS_UART_BD_RT_REG_RESET_VALUE;
		}
		else {
			p_reg_base->baud_rate_generator = PS_UART_BD_GN_REG_DEF_VALUE;
			p_reg_base->mode |= (PS_UART_CLK_SELECT_NONDIV8_VALUE << PS_UART_CLK_SELECT_BIT_0_OFFSET);
			p_reg_base->baud_rate_divider = (XPAR_XUARTPS_0_UART_CLK_FREQ_HZ  / (baud_rate * PS_UART_BD_GN_REG_DEF_VALUE)) - 1;
		}
	}
	else {
		p_reg_base->baud_rate_generator = PS_UART_BD_GN_REG_RESET_VALUE;
		p_reg_base->mode |= (PS_UART_MODE_REG_RESET_VALUE & PS_UART_CLK_SELECT_BIT_MASK);
		p_reg_base->baud_rate_divider = PS_UART_BD_RT_REG_RESET_VALUE;
	}
}

static inline char get_data_word_(ps_uart_regs *p_reg_base) {
	while((p_reg_base->channel_int & 0x2) == 0x2); // todo: mask
	return p_reg_base->tx_rx_fifo;
}

static inline void set_data_word_(ps_uart_regs *p_reg_base, char data) {
	while((p_reg_base->channel_int & 0x8) != 0x8);
	p_reg_base->tx_rx_fifo = data;
}

static inline void set_tx_enable_(ps_uart_regs *p_reg_base, bool do_setting) {
	if (true == do_setting) {
		p_reg_base->control |= (TRUE << PS_UART_TX_ENABLE_BIT_OFFSET) | (TRUE << PS_UART_RX_ENABLE_BIT_OFFSET);
	}
	else {
		//p_reg_base->control |= (TRUE << PS_UART_TX_DISABLE_BIT_OFFSET) | (TRUE << PS_UART_RX_DISABLE_BIT_OFFSET);
	}
}

static inline void set_reset_(ps_uart_regs *p_reg_base, ps_uart_path_reset path_reset, bool *reset_done) {
	switch (path_reset) {
	case tx:
	    p_reg_base->control |= (TRUE << PS_UART_TX_RESET_BIT_OFFSET);
	    *reset_done = !(p_reg_base->control & (TRUE << PS_UART_TX_RESET_BIT_OFFSET));
	break;
	case rx:
		p_reg_base->control |= (TRUE << PS_UART_RX_RESET_BIT_OFFSET);
		*reset_done = !(p_reg_base->control & (TRUE << PS_UART_RX_RESET_BIT_OFFSET));
	break;
	case both:
		p_reg_base->control |= (TRUE << PS_UART_TX_RESET_BIT_OFFSET) | (TRUE << PS_UART_RX_RESET_BIT_OFFSET);
		*reset_done = !(p_reg_base->control & ((TRUE << PS_UART_TX_RESET_BIT_OFFSET) | (TRUE << PS_UART_RX_RESET_BIT_OFFSET)));
	break;
	default:
		*reset_done = 0;
    break;
	}
}

//todo: навести порядок
static inline void set_interrupt_(ps_uart_regs *p_uart_regs, uint32_t interrupt_mask) {
	p_uart_regs->interrupt_enable = 0x1FF & interrupt_mask;
}


static inline void set_rx_fifo_level(ps_uart_regs *p_reg_base, uint8_t rx_fifo_level, bool do_setting)
{
	if (true == do_setting) {
		p_reg_base->rx_fifo_level = rx_fifo_level;
	}
	else {
		p_reg_base->rx_fifo_level = PS_UART_RX_FIFO_LVL_REG_RESET_VALUE;
	}
}

//---------------------------------------------interrupts---------------------------------------------//

static void intrrupt_handler(void *callback)
{
	ps_uart_regs *uart_regs = (ps_uart_regs *)ps_usart_id_1;


	if (uart_regs->interrupt_int & PS_UART_RX_FIFO_TRIG_INTR_MSK) {
		asm("nop");
	}

	if (uart_regs->interrupt_int & PS_UART_RX_FIFO_EMPTY_INTR_MSK) {
		asm("nop");
	}

	if (uart_regs->interrupt_int & PS_UART_RX_FIFO_FULL_INTR_MSK) {
		asm("nop");
	}

	if (uart_regs->interrupt_int & PS_UART_TX_FIFO_EMPTY_INTR_MSK) {
		//todo:hardcode: 0
		//tx_ready[0] = true;

		uart_regs->interrupt_enable = 0x1FF;

/*		// todo: hardcode: 0x1FF
		uart_regs->interrupt_disable = 0x1FF;

		if (num[0] > ii) {
			// todo: hardcode: 0
			set_data_word_(uart_regs, un_block_array[0][ii]);
			ii++;
			// todo: hardcode: 0x1FF
			uart_regs->interrupt_enable = 0x1FF;
		}*/
	}

	if (uart_regs->interrupt_int & PS_UART_TX_FIFO_FULL_INTR_MSK) {
		asm("nop");
	}

	if (uart_regs->interrupt_int & PS_UART_RX_OVERFLOW_INTR_MSK) {
		asm("nop");
	}

	if (uart_regs->interrupt_int & PS_UART_RX_FRME_ERROR_INTR_MSK) {
		asm("nop");
	}

	if (uart_regs->interrupt_int & PS_UART_RX_PART_ERROR_INTR_MSK) {
		asm("nop");
	}

	if (uart_regs->interrupt_int & PS_UART_RX_TMOUT_ERROR_INTR_MSK) {
	    asm("nop");
	}

	if (uart_regs->interrupt_int & PS_UART_MD_int_INDR_INTR_MSK) {
	    asm("nop");
	}

	if (uart_regs->interrupt_int & PS_UART_TX_FIFO_TRIG_INTR_MSK) {
	    asm("nop");
	}

	if (uart_regs->interrupt_int & PS_UART_TX_FIFO_NRFULL_INTR_MSK) {
	//	tx_ready[0] = false;
		set_tx_enable_(uart_regs, true);
	}

	if (uart_regs->interrupt_int & PS_UART_TX_OVERFLOW_INTR_MSK) {
		asm("nop");
	}
}
